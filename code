=======================================
INICIO FICHERO >> ./tests/lib/locator_map.ts
=======================================
// Mapa central de selectores
export const locatorMap: Record<string, string> = {
  'users.nameInput': 'input[placeholder="Name"]',
  'users.emailInput': 'input[placeholder="Email"]',
  'users.roleSelect': 'select',
  'users.addButton': 'button:has-text("Add")',
  'users.userRows': 'table tbody tr',

  'orders.customerInput': 'input[placeholder="Customer"]',
  'orders.productInput': 'input[placeholder="Product"]',
  'orders.quantityInput': 'input[placeholder="Quantity"]',
  'orders.statusInput': 'input[placeholder="Status"]',
  'orders.addButton': 'button:has-text("Add Order")',
  'orders.orderRows': 'table tbody tr'
};
=======================================
FIN FICHERO >> ./tests/lib/locator_map.ts
=======================================

=======================================
INICIO FICHERO >> ./tests/lib/heal_locators.ts
=======================================
import { Page, Locator } from '@playwright/test';
import { locatorMap } from './locator_map';

export class HealLocator {
  readonly page: Page;

  constructor(page: Page) {
    this.page = page;
  }

  get(key: string): Locator {
    const selector = locatorMap[key];
    if (!selector) throw new Error(`Selector no encontrado para clave: ${key}`);
    return this.page.locator(selector);
  }

  async safeClick(key: string) {
    const loc = this.get(key);
    try {
      await loc.click();
    } catch {
      await this.recoverSelector(key, 'click');
    }
  }

  async safeFill(key: string, value: string) {
    const loc = this.get(key);
    try {
      await loc.fill(value);
    } catch {
      await this.recoverSelector(key, 'fill', value);
    }
  }

  async recoverSelector(key: string, action: string, value?: string) {
    console.warn(`⚠ Selector roto: ${key}. Intentando recuperación...`);

    // Intento simple: buscar por texto aproximado
    const approxText = key.split('.').pop()?.replace(/Input|Button|Select|Rows/gi, '');
    const candidate = this.page.locator(`text=${approxText}`);

    if (await candidate.count() > 0) {
      console.info(`✅ Recuperado dinámicamente: ${key} → text=${approxText}`);
      locatorMap[key] = `text=${approxText}`;
      if (action === 'click') await candidate.first().click();
      if (action === 'fill' && value) await candidate.first().fill(value);
      return;
    }

    throw new Error(`No se pudo recuperar selector para: ${key}`);
  }
}
=======================================
FIN FICHERO >> ./tests/lib/heal_locators.ts
=======================================

=======================================
INICIO FICHERO >> ./tests/pages/base.page.ts
=======================================
import { Page } from '@playwright/test';
import { HealLocator } from '../lib/heal_locators';

export class BasePage {
  readonly page: Page;
  readonly hl: HealLocator;

  constructor(page: Page) {
    this.page = page;
    this.hl = new HealLocator(page);
  }

  async goto(path: string) {
    await this.page.goto(path);
  }
}
=======================================
FIN FICHERO >> ./tests/pages/base.page.ts
=======================================

=======================================
INICIO FICHERO >> ./tests/pages/users.page.ts
=======================================
import { BasePage } from './base.page';

export class UsersPage extends BasePage {
  async goto() {
    await super.goto('/users');
  }

  async createUser(name: string, email: string, role: string = 'user') {
    await this.hl.safeFill('users.nameInput', name);
    await this.hl.safeFill('users.emailInput', email);
    await this.page.selectOption('select', role);
    await this.hl.safeClick('users.addButton');
  }

  async deleteUserByIndex(index: number) {
    const rows = this.hl.get('users.userRows');
    const deleteBtn = rows.nth(index).locator('button:has-text("Delete")');
    await deleteBtn.click();
  }

  async getUsersCount() {
    return await this.hl.get('users.userRows').count();
  }
}
=======================================
FIN FICHERO >> ./tests/pages/users.page.ts
=======================================

=======================================
INICIO FICHERO >> ./tests/pages/orders.page.ts
=======================================
import { BasePage } from './base.page';

export class OrdersPage extends BasePage {
  async goto() {
    await super.goto('/orders');
  }

  async createOrder(customer: string, product: string, quantity: number, status: string) {
    await this.hl.safeFill('orders.customerInput', customer);
    await this.hl.safeFill('orders.productInput', product);
    await this.hl.safeFill('orders.quantityInput', quantity.toString());
    await this.hl.safeFill('orders.statusInput', status);
    await this.hl.safeClick('orders.addButton');
  }

  async deleteOrderByIndex(index: number) {
    const rows = this.hl.get('orders.orderRows');
    const deleteBtn = rows.nth(index).locator('button:has-text("Delete")');
    await deleteBtn.click();
  }

  async getOrdersCount() {
    return await this.hl.get('orders.orderRows').count();
  }
}
=======================================
FIN FICHERO >> ./tests/pages/orders.page.ts
=======================================

=======================================
INICIO FICHERO >> ./tests/flows/user.flows.ts
=======================================
import { Page, expect } from '@playwright/test';
import { UsersPage } from '../pages/users.page';

export async function createAndDeleteUserFlow(page: Page) {
  const usersPage = new UsersPage(page);

  await usersPage.goto();
  const initialCount = await usersPage.getUsersCount();

  await usersPage.createUser('Test User', 'test@example.com');
  await expect(usersPage.hl.get('users.userRows')).toHaveCount(initialCount + 1);

  await usersPage.deleteUserByIndex(0);
  await expect(usersPage.hl.get('users.userRows')).toHaveCount(initialCount);
}
=======================================
FIN FICHERO >> ./tests/flows/user.flows.ts
=======================================

=======================================
INICIO FICHERO >> ./tests/flows/order.flows.ts
=======================================
import { Page, expect } from '@playwright/test';
import { OrdersPage } from '../pages/orders.page';

export async function createAndDeleteOrderFlow(page: Page) {
  const ordersPage = new OrdersPage(page);

  await ordersPage.goto();
  const initialCount = await ordersPage.getOrdersCount();

  await ordersPage.createOrder('Test Customer', 'Test Product', 5, 'Pending');
  await expect(ordersPage.hl.get('orders.orderRows')).toHaveCount(initialCount + 1);

  await ordersPage.deleteOrderByIndex(0);
  await expect(ordersPage.hl.get('orders.orderRows')).toHaveCount(initialCount);
}
=======================================
FIN FICHERO >> ./tests/flows/order.flows.ts
=======================================

=======================================
INICIO FICHERO >> ./tests/e2e/flows.spec.ts
=======================================
import { test } from '@playwright/test';
import { createAndDeleteUserFlow } from '../flows/user.flows';
import { createAndDeleteOrderFlow } from '../flows/order.flows';

test('Flujo completo con autocuración', async ({ page }) => {
  await createAndDeleteUserFlow(page);
  await createAndDeleteOrderFlow(page);
});
=======================================
FIN FICHERO >> ./tests/e2e/flows.spec.ts
=======================================
